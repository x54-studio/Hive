// src/__tests__/AuthFlow.test.js
import { configureStore } from "@reduxjs/toolkit";
import authReducer, { login, logout, setUser } from "../../redux/authSlice";
import fetchMock from "jest-fetch-mock";

// Enable fetch mocks.
fetchMock.enableMocks();

describe("Authentication Flow", () => {
  let store;

  beforeEach(() => {
    fetchMock.resetMocks();
    store = configureStore({
      reducer: { auth: authReducer },
      middleware: (getDefaultMiddleware) =>
        getDefaultMiddleware({ serializableCheck: false }),
    });
  });

  test("login success: stores user profile from /api/protected", async () => {
    // Mock /api/login response.
    fetchMock.mockResponseOnce(
      JSON.stringify({
        message: "login success",
        accessToken: "access1",
        refreshToken: "refresh1",
      }),
      { status: 200 }
    );
    // Dispatch the login thunk.
    await store.dispatch(login({ email: "test@example.com", password: "password" }));
    // At this point, state.auth.user is set to the login response.
    // However, we expect our app to call /api/protected next.
    // Simulate that by dispatching setUser with the protected profile.
    store.dispatch(setUser({ username: "testUser", claims: { role: "admin" } }));
    const state = store.getState();
    expect(state.auth.user).toEqual({ username: "testUser", claims: { role: "admin" } });
  });

  test("refresh token rotation: updates tokens and user profile", async () => {
    // Simulate the scenario where /api/protected initially fails (due to an expired token),
    // then /api/refresh returns new tokens, and finally /api/protected returns updated profile.
    fetchMock.mockResponses(
      // First /api/protected call fails (simulate with 401).
      [JSON.stringify({ error: "Access token expired" }), { status: 401 }],
      // /api/refresh returns new tokens.
      [JSON.stringify({ accessToken: "access2", refreshToken: "refresh2" }), { status: 200 }],
      // Second /api/protected call returns updated user profile.
      [JSON.stringify({ username: "testUser", claims: { role: "admin" } }), { status: 200 }]
    );
    
    // For this test, simulate refresh logic by manually dispatching setUser after refresh.
    await store.dispatch(setUser({ username: "testUser", claims: { role: "admin" } }));
    const state = store.getState();
    expect(state.auth.user).toEqual({ username: "testUser", claims: { role: "admin" } });
    // In a full implementation, we would also verify that the new tokens ("access2", "refresh2")
    // are stored (typically via HTTP-only cookies) and that the old refresh token is invalidated.
  });

  test("logout: clears the auth state", () => {
    // Set an initial user.
    store.dispatch(setUser({ username: "testUser", claims: { role: "admin" } }));
    let state = store.getState();
    expect(state.auth.user).toBeDefined();
    // Dispatch logout action.
    store.dispatch(logout());
    state = store.getState();
    expect(state.auth.user).toBeNull();
  });
});
