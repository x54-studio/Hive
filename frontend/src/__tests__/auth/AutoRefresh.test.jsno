import axios from 'axios';
import { configureStore } from '@reduxjs/toolkit';
import authReducer from '../../redux/authSlice';
import thunk from 'redux-thunk';
import { refreshTokens } from '../../redux/authActions'; // Adjust this path if your file is named differently

// Define the initial auth state with an expired access token.
const initialState = {
  auth: {
    user: {
      username: 'testUser',
      accessToken: 'expiredToken',
      refreshToken: 'validRefreshToken',
      claims: { role: 'admin' },
    },
    loading: false,
    error: null,
  },
};

let store;
let interceptorId;

beforeEach(() => {
  // Create the Redux store with default middleware.
  store = configureStore({
    reducer: { auth: authReducer },
    preloadedState: initialState,
    // No need to manually add middleware here since getDefaultMiddleware() is used internally.
  });

  // Set up an Axios response interceptor to simulate autoâ€‘refresh on 401 responses.
  interceptorId = axios.interceptors.response.use(
    (response) => response,
    async (error) => {
      console.log("Interceptor caught error:", error);
      if (
        error.response &&
        error.response.status === 401 &&
        !error.config._retry
      ) {
        error.config._retry = true;
        console.log("Triggering refresh token request...");
        // Call the refresh endpoint.
        const refreshResponse = await axios.post(
          "http://localhost:5000/api/refresh",
          {},
          { withCredentials: true }
        );
        console.log("Refresh response:", refreshResponse.data);
        // Dispatch an action to update the auth state.
        store.dispatch({
          type: "auth/refreshTokens/fulfilled",
          payload: refreshResponse.data,
        });
        // Update the original request's headers with the new access token.
        error.config.headers = error.config.headers || {};
        error.config.headers.Authorization = `Bearer ${refreshResponse.data.accessToken}`;
        // Retry the original request.
        return axios(error.config);
      }
      return Promise.reject(error);
    }
  );
});

afterEach(() => {
  if (axios.interceptors.response.eject && interceptorId !== undefined) {
    axios.interceptors.response.eject(interceptorId);
  }
  jest.resetAllMocks();
});

test("calls refresh token endpoint and updates user with new token data", async () => {
  // Define the new user data expected after a successful refresh.
  const newUserData = {
    username: "testUser",
    accessToken: "newAccessToken",
    refreshToken: "newRefreshToken",
    claims: { role: "admin" },
  };

  // Simulate that the initial GET request fails with a 401.
  axios.get.mockRejectedValueOnce({
    response: { status: 401 },
    config: { headers: {} },
  });

  // Simulate that the refresh token endpoint returns new token data.
  axios.post.mockResolvedValueOnce({
    data: newUserData,
  });

  // Simulate that the retried GET request now succeeds.
  axios.get.mockResolvedValueOnce({
    data: { message: "Protected data" },
  });

  // Define an API call that uses axios.
  const apiCall = async () => {
    return axios.get("http://localhost:5000/api/protected", {
      withCredentials: true,
    });
  };

  // Make the API call.
  const response = await apiCall();

  // Verify that the refresh endpoint was called.
  expect(axios.post).toHaveBeenCalledWith(
    "http://localhost:5000/api/refresh",
    {},
    { withCredentials: true }
  );

  // Verify that the final GET response is as expected.
  expect(response.data).toEqual({ message: "Protected data" });

  // Verify that the Redux state was updated with the new token data.
  const state = store.getState();
  console.log("Updated auth state:", state.auth.user);
  expect(state.auth.user).toEqual(newUserData);
});
